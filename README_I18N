Generate gettext infrastructure
-------------------------------

Erlydtl allows templates to use i18n features based on gettext or a custom i18n
support. Standard po files can be used to generate i18ized templates. A template
parser/po generator is also provided.

For enabling gettext-based i18n support:

    1.  First, you'll need gettext library to be available on your lib_path.

        Library can be downloaded from http://github.com/noss/erlang-gettext

    2.  Then you'll need to add a parse target on your makefile (or the script
        used to trigger template reparsing) trans:

        erl -pa ./ebin ./deps/*/ebin -noshell -s reloader -run i18n_manager \
                               generate_pos "en,es" "./views/*/*.html,./views/*.html"
        rm -rf $(GETTEXT_DIR)/lang/default-old
        mv $(GETTEXT_DIR)/lang/default $(GETTEXT_DIR)/lang/default-old
        cp -rf $(GETTEXT_DIR)/lang/$(GETTEXT_TMP_NAME) $(GETTEXT_DIR)/lang/default
        rm -rf $(GETTEXT_DIR)/lang/$(GETTEXT_TMP_NAME)/*

        Mind that GETTEXT_DIR and GETTEXT_TMP_NAME must be bound to existing
        directories. Args passed to i18n_manager:generate_pos are locales that
        will be supported (generating dir structure and po files) and
        directories where generator will search for template files including
        trans tags.

    3.  Before template parsing gettext server must be running and it must be
        populated with the content of the po files. Consider adding this
        snipplet to the code before template parsing

	gettext_server:start(),
        LoadPo = 
            fun(Lang)->
                {_, Bin} = file:read_file("./lang/default/"++ Lang ++"/gettext.po"),
                gettext:store_pofile(Lang, Bin)
            end,
        lists:map(LoadPo, ["es","en"]).

        Here locales are the codes are provided to gettext. Those codes must be
        a subset of the locales provided to po generation process.

    4.  Update strings. Edit po files on $(GETTEXT_DIR)/lang/default/$(LOCALE)/gettext.po 
        translating msgstr to the translated version of their corresponding msgstr.

    5.  Generate localized templates providing locale compile option.

For enabling custom i18n support:

    1.  Pass {translater, {Module, Function}} configuration option to the template
        compiler.  This Module:Function/2 must implement translation in the form:

        Module:Function(MsgID, Locale) -> Text
            MsgID  = integer() | string()
            Locale = atom() | string() | binary()
            Text   = string() | binary()

    2. Implementation of the translation logic by the Module:Function/2 mentioned
       above is beyond the scope of this project. A sample gettext alternative project is:
       https://github.com/saleyn/ei18n

       Create an XML file with specifications of language-specific text translations
       in the format specified in the link above: `priv/i18n.xml`

       Include a rebar dependency in your project:
       `{deps, [{ei18n, ".*", {git, "git://github.com/saleyn/ei18n.git", "master"}}]}.`

       Include rebar configuration options:
       {plugin_dir, "deps/ei18n/priv"}.
       {plugins, [ei18n_rebar_plugin]}.             % use ei18n project's rebar plugin
       {ei18n_opts, [{xml_file, "priv/i18n.xml"}]}. % tell the plugin location of translation
                                                    % XML file
       {erlydtl_opts, [
           {included_headers, ["ei18n.hrl"]},       % use include file generated by plugin
           {translater, {ei18n, get}}               % use ei18n:get/2 function for transcation
       ]}.

    Each translation entry in the XML specification (e.g. "priv/i18n.xml") contains
    a static/dynamic specifier.  Static entries are converted to language-specific
    constants returned by `ei18n:get(ID, Locale)` calls, where ID is a constant
    identifier used in a DTL template in the form: `{% trans "?ABC" %}`.  The
    question mark indicates that the `ABC` is a macro specified in the generated
    `ei18n.hrl` header.  The dynamic entries are looked up at run-time from
    the translation server `ei18n_trans_server` module, and are referenced in
    templates without a question mark: `{% trans "EFG" %}`.
